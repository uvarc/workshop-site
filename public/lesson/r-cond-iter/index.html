<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Conditionals and Iteration - SOMRC Workshops</title>
  <meta property="og:title" content="Conditionals and Iteration - SOMRC Workshops" />
  <meta name="twitter:title" content="Conditionals and Iteration - SOMRC Workshops" />
  <meta name="description" content="Introduction The ability to use logic to condition execution of a program is fundamental to many languages. These control-flow features are primarily implemented in R through a series of “reserved” words:
?reserved We can access the documentation on R’s implementation of control flow statements through any of the relevant reserved words:
?`if` ?`else` ?`for` ?`break` ?`while` ?`repeat` Note the back ticks around the names of these statements. The reservation on these names prevents them from being assigned another value.">
  <meta property="og:description" content="Introduction The ability to use logic to condition execution of a program is fundamental to many languages. These control-flow features are primarily implemented in R through a series of “reserved” words:
?reserved We can access the documentation on R’s implementation of control flow statements through any of the relevant reserved words:
?`if` ?`else` ?`for` ?`break` ?`while` ?`repeat` Note the back ticks around the names of these statements. The reservation on these names prevents them from being assigned another value.">
  <meta name="twitter:description" content="Introduction The ability to use logic to condition execution of a program is fundamental to many languages. These control-flow features are primarily implemented in R through a series of “reserved” …">
  <meta name="author" content=""/>
  <meta property="og:site_name" content="SOMRC Workshops" />
  <meta property="og:url" content="/lesson/r-cond-iter/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.37.1" />
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.0.10/js/all.js" integrity="sha384-slN8GvtUJGnv6ca26v8EzVaR9DC58QEwsIk9q1QXdCU8Yu8ck/tL/5szYlBbqmS+" crossorigin="anonymous"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">SOMRC Workshops</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-tags"><a href="/lesson/" title="Lessons">Lessons</a></li>
      <li class="site-navi-item-topics"><a href="/categories/" title="Topics">Topics</a></li>
      <li class="site-navi-item-data"><a href="/data/" title="Data">Data</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">Conditionals and Iteration</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        
        <li class="article-meta-categories">
          <a href="/categories/r-programming/">
            <i class="fas fa-folder"></i>
            R PROGRAMMING
          </a>&nbsp;
        </li>
      </ul>
      
<aside class="toc">
  
</aside>
      <div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>The ability to use logic to condition execution of a program is fundamental to many languages. These <em>control-flow</em> features are primarily implemented in R through a series of “reserved” words:</p>
<pre class="r"><code>?reserved</code></pre>
<p>We can access the documentation on R’s implementation of control flow statements through any of the relevant reserved words:</p>
<pre class="r"><code>?`if`
?`else`
?`for`
?`break`
?`while`
?`repeat`</code></pre>
<p>Note the back ticks around the names of these statements. The reservation on these names prevents them from being assigned another value. It also introduces a concept that is important, particularly for more advanced programming tasks in R:</p>
<blockquote>
<p><em>Everything that happens is a function call<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</em></p>
</blockquote>
<p>Although the syntax is a bit different, these statements are actually functions that can accept arguments and return values. As we saw in the control flow help file, the parameters can include:</p>
<ul>
<li><code>cond</code> = a logical condition (i.e. <code>TRUE</code> or <code>FALSE</code>) … used with <code>if</code> and <code>while</code></li>
<li><code>var</code> = a placeholder name for one member of a sequence … used with <code>for</code></li>
<li><code>seq</code> = a sequence over which to iterate … used with <code>for</code></li>
<li><code>expr</code> = the “result” or expression to evaluate after logic is complete … used with <em>most</em> statements</li>
</ul>
<p>We can illustrate how these statements behave as functions with the following:</p>
<pre class="r"><code>`if`(cond = months(Sys.Date()) %in% month.name[6:8], 
     cons.expr = &quot;summer!&quot;,
     alt.expr = &quot;not summer!&quot;)</code></pre>
<p>The syntax above is a bit arcane … and we’ll discuss a more common (and legible) way to formulate an if-else statement below. But the principle that these statements are functions is helpful in understanding how they behave.</p>
<div id="if-else" class="section level3">
<h3><code>if</code> / <code>else</code></h3>
<p>R provides some helpful syntax for using them to implement the functions for <code>if</code> and <code>else</code> conditional statements.</p>
<p>Let’s return to the example above.</p>
<p>The if statement could be written as we have it … but more colloquially would be written as follows:</p>
<pre class="r"><code>if (months(Sys.Date()) %in% month.name[6:8]) {
  
  &quot;summer!&quot;
  
} else {
  
  &quot;not summer!&quot;
  
}</code></pre>
<pre><code>## [1] &quot;not summer!&quot;</code></pre>
<p>We can break down the logic by starting with some pseudo code of what we want to achieve:</p>
<pre><code>if the current month is june, july or august
  print &quot;summer!&quot;
otherwise 
  print &quot;not summer!&quot;</code></pre>
<p>This logic operates on the following question:</p>
<p>Is the current month …</p>
<ol style="list-style-type: lower-alpha">
<li>either June, July or August</li>
<li>neither June, July nor August</li>
</ol>
<p>As we can see, the answer to this question is binary, and can therefore evaluate to a simple <code>TRUE</code> or <code>FALSE</code>.</p>
<p>We construct this test using <code>%in%</code>, which is a built-in operator for determining whether or not there are matching values between vectors. <code>months(Sys.Date())</code> gives us a character vector of length 1 with the full name of the current month.</p>
<pre class="r"><code>Sys.Date()</code></pre>
<pre><code>## [1] &quot;2018-09-02&quot;</code></pre>
<pre class="r"><code>months(Sys.Date())</code></pre>
<pre><code>## [1] &quot;September&quot;</code></pre>
<p>And <code>month.name[6:8]</code> gives us a vector of length 3 with the full names of the 6th, 7th and 8th months of the year.</p>
<pre class="r"><code>month.name</code></pre>
<pre><code>##  [1] &quot;January&quot;   &quot;February&quot;  &quot;March&quot;     &quot;April&quot;     &quot;May&quot;      
##  [6] &quot;June&quot;      &quot;July&quot;      &quot;August&quot;    &quot;September&quot; &quot;October&quot;  
## [11] &quot;November&quot;  &quot;December&quot;</code></pre>
<pre class="r"><code>month.name[6:8]</code></pre>
<pre><code>## [1] &quot;June&quot;   &quot;July&quot;   &quot;August&quot;</code></pre>
<p>So is the current month one of these three?</p>
<pre class="r"><code>months(Sys.Date()) %in% month.name[6:8]</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>We might consider saving ourselves a few keystrokes and assigning this test to an object:</p>
<pre class="r"><code>summer_test &lt;- months(Sys.Date()) %in% month.name[6:8]</code></pre>
<p>From there we can use the expressions (code inside of <code>{</code> squigly braces) following <code>if</code> and <code>else</code> to define what action we should take on <code>TRUE</code> and <code>FALSE</code> respectively. In this case it’s simply a matter of printing different strings.</p>
<div id="else-if" class="section level4">
<h4><code>else if</code></h4>
<p><code>if</code> / <code>else</code> statements don’t have to stop after one logical test. Given that the first <code>if</code> fails, you can continue to condition the statement arbitrarily with <code>else if</code>:</p>
<pre class="r"><code>if (summer_test) {
  
  &quot;summer!&quot;
  
} else if (weekdays(Sys.Date()) == &quot;Saturday&quot;) {
  
  &quot;not summer ... but it&#39;s saturday!&quot;
  
} else {
  
  &quot;not summer. not saturday.&quot;
  
}</code></pre>
<pre><code>## [1] &quot;not summer. not saturday.&quot;</code></pre>
<p>Note that the final <code>else</code> is very important, as it closes out the logical possibilities. Without it, the statement wouldn’t print anything if both the <code>if</code> and <code>else if</code> fail.</p>
<p>As an aside, we can also make the logical argument to <code>if</code> / <code>else</code> more complex with boolean operators. For example if we wanted to satisfy two conditions simultaneously we could use <code>&amp;&amp;</code>:</p>
<pre class="r"><code>x &lt;- 12

if (x &gt; 10 &amp;&amp; x%%2 == 0) {
  
  &quot;big and even&quot;
  
} else {
  
  &quot;small or odd&quot;
  
}</code></pre>
<pre><code>## [1] &quot;big and even&quot;</code></pre>
<pre class="r"><code>x &lt;- 13

if (x &gt; 10 &amp;&amp; x%%2 == 0) {
  
  &quot;big and even&quot;
  
} else {
  
  &quot;small or odd&quot;
  
}</code></pre>
<pre><code>## [1] &quot;small or odd&quot;</code></pre>
<p>And if we wanted to test either one or both of the conditions simultaneously, we could use <code>||</code>:</p>
<pre class="r"><code>x &lt;- 4

if (x &gt; 10 || x%%2 == 0) {
  
  &quot;big or even&quot;
  
} else {
  
  &quot;small or odd&quot;
  
}</code></pre>
<pre><code>## [1] &quot;big or even&quot;</code></pre>
<pre class="r"><code>x &lt;- 3

if (x &gt; 10 &amp;&amp; x%%2 == 0) {
  
  &quot;big or even&quot;
  
} else {
  
  &quot;small or odd&quot;
  
}</code></pre>
<pre><code>## [1] &quot;small or odd&quot;</code></pre>
</div>
<div id="ifelse" class="section level4">
<h4><code>ifelse()</code></h4>
<p>For brevity, there is a single function to manage <code>if</code> / <code>else</code> control flow. <code>ifelse()</code> takes three arguments:</p>
<ul>
<li><code>test</code> = a condition that evalues to <code>TRUE</code> or <code>FALSE</code></li>
<li><code>yes</code> = the value(s) to be returned for <code>TRUE</code></li>
<li><code>no</code> = the value(s) to be returned for <code>FALSE</code></li>
</ul>
<p><code>ifelse</code> can be particularly useful as a helper function. Here’s an example of using it in a data manipulation pipeline with <strong>dplyr</strong>:</p>
<pre class="r"><code>library(dplyr)

mtcars %&gt;% 
  mutate(transmission = ifelse(am == 1, &quot;Manual&quot;, &quot;Automatic&quot;)) %&gt;%
  select(transmission, mpg)</code></pre>
<pre><code>##    transmission  mpg
## 1        Manual 21.0
## 2        Manual 21.0
## 3        Manual 22.8
## 4     Automatic 21.4
## 5     Automatic 18.7
## 6     Automatic 18.1
## 7     Automatic 14.3
## 8     Automatic 24.4
## 9     Automatic 22.8
## 10    Automatic 19.2
## 11    Automatic 17.8
## 12    Automatic 16.4
## 13    Automatic 17.3
## 14    Automatic 15.2
## 15    Automatic 10.4
## 16    Automatic 10.4
## 17    Automatic 14.7
## 18       Manual 32.4
## 19       Manual 30.4
## 20       Manual 33.9
## 21    Automatic 21.5
## 22    Automatic 15.5
## 23    Automatic 15.2
## 24    Automatic 13.3
## 25    Automatic 19.2
## 26       Manual 27.3
## 27       Manual 26.0
## 28       Manual 30.4
## 29       Manual 15.8
## 30       Manual 19.7
## 31       Manual 15.0
## 32       Manual 21.4</code></pre>
<p>The function can behave very similarly to the traditional <code>if</code> / <code>else</code> statement:</p>
<pre class="r"><code>if (summer_test) {
  
  &quot;summer!&quot;
  
} else {
  
  &quot;not summer!&quot;
  
}</code></pre>
<pre><code>## [1] &quot;not summer!&quot;</code></pre>
<pre class="r"><code>ifelse(summer_test, &quot;summer!&quot;, &quot;not summer!&quot;)</code></pre>
<pre><code>## [1] &quot;not summer!&quot;</code></pre>
<p>Both of the cases above achieve the same result, but there are a couple of fundamental differences between the two approaches. <code>?ifelse</code> gives us some insight to the nature of the values the function returns:</p>
<blockquote>
<p>A vector of the same length and attributes (including dimensions and “class”) as test and data values from the values of yes or no.</p>
</blockquote>
<p>We can see that the return value is a <em>vector</em> … as such, <code>ifelse()</code> has a distinct advantage over the more explicit <code>if</code> / <code>else</code> syntax in that it is <strong>vectorized</strong>. We’ll talk more about vectorization and its advantages in the context of iteration and loops, but we can see some of its benefits already with <code>ifelse()</code>.</p>
<p>For example, say we had a test that evaluated multiple elements:</p>
<pre class="r"><code>x &lt;- 1:10

x &gt; 5</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE</code></pre>
<p>If we were to use this in a traditonal <code>if</code> / <code>else</code> statement, we would get a warning:</p>
<pre class="r"><code>if (x &gt; 5) {
  
  &quot;large&quot;
  
} else {
  
  &quot;small&quot;
  
}</code></pre>
<pre><code>## Warning in if (x &gt; 5) {: the condition has length &gt; 1 and only the first
## element will be used</code></pre>
<pre><code>## [1] &quot;small&quot;</code></pre>
<p>But with <code>ifelse()</code>, we get a return vector of the same length as the test:</p>
<pre class="r"><code>ifelse(x &gt; 5, &quot;large&quot;, &quot;small&quot;)</code></pre>
<pre><code>##  [1] &quot;small&quot; &quot;small&quot; &quot;small&quot; &quot;small&quot; &quot;small&quot; &quot;large&quot; &quot;large&quot; &quot;large&quot;
##  [9] &quot;large&quot; &quot;large&quot;</code></pre>
<p>Note that this vectorization can result in some potentially unexpected behavior. As the examples in the help file for <code>ifelse()</code> indicate, the function can occassionally strip important attributes for the return vector. Let’s try the following to demonstrate:</p>
<pre class="r"><code>ifelse(1 &lt; 2, Sys.Date(), NA)</code></pre>
<pre><code>## [1] 17776</code></pre>
<p>What’s that all about? Weren’t we returning a <em>date</em> for <code>TRUE</code>?</p>
<p>As it turns out, <code>ifelse</code> has stripped the date attribute:</p>
<pre class="r"><code>class(ifelse(1 &lt; 2, Sys.Date(), NA))</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>And what we are left with is the numeric representation of the date (i.e. days since origin, which defaults to “1970-01-01”):</p>
<pre class="r"><code>Sys.Date()</code></pre>
<pre><code>## [1] &quot;2018-09-02&quot;</code></pre>
<pre class="r"><code>as.numeric(Sys.Date())</code></pre>
<pre><code>## [1] 17776</code></pre>
<pre class="r"><code>as.Date(as.numeric(Sys.Date()), origin = &quot;1970-01-01&quot;)</code></pre>
<pre><code>## [1] &quot;2018-09-02&quot;</code></pre>
<pre class="r"><code>dput(as.Date(as.numeric(Sys.Date()), origin = &quot;1970-01-01&quot;))</code></pre>
<pre><code>## structure(17776, class = &quot;Date&quot;)</code></pre>
<p>The more explicit <code>if</code> / <code>else</code> syntax, on the other hand, will preserve the date attributes:</p>
<pre class="r"><code>if(1 &lt; 2) {
  
  Sys.Date()
  
  } else {
    
    NA
    
    }</code></pre>
<pre><code>## [1] &quot;2018-09-02&quot;</code></pre>
<pre class="r"><code>class (
  
  if(1 &lt; 2) {
    
    Sys.Date()
    
    } else {
      
      NA 
    }
  
)</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
</div>
<div id="switch" class="section level4">
<h4><code>switch()</code></h4>
<p><code>switch()</code> provides yet another way to evaluate conditional logic in R. This function can be helpful for saving time with coding (and making code more legibile), particularly when there are a number of conditions to satisfy<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<pre class="r"><code>switch(EXPR = &quot;foo&quot;, 
       &quot;foo&quot; = 1:10,
       &quot;bar&quot; = 11:20,
       &quot;baz&quot; = 21:30,
       &quot;bop&quot; = 31:40)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<pre class="r"><code>switch(EXPR = &quot;bar&quot;, 
       &quot;foo&quot; = 1:10,
       &quot;bar&quot; = 11:20,
       &quot;baz&quot; = 21:30,
       &quot;bop&quot; = 31:40)</code></pre>
<pre><code>##  [1] 11 12 13 14 15 16 17 18 19 20</code></pre>
<pre class="r"><code>switch(EXPR = &quot;baz&quot;, 
       &quot;foo&quot; = 1:10,
       &quot;bar&quot; = 11:20,
       &quot;baz&quot; = 21:30,
       &quot;bop&quot; = 31:40)</code></pre>
<pre><code>##  [1] 21 22 23 24 25 26 27 28 29 30</code></pre>
<pre class="r"><code>switch(EXPR = &quot;bop&quot;, 
       &quot;foo&quot; = 1:10,
       &quot;bar&quot; = 11:20,
       &quot;baz&quot; = 21:30,
       &quot;bop&quot; = 31:40)</code></pre>
<pre><code>##  [1] 31 32 33 34 35 36 37 38 39 40</code></pre>
</div>
</div>
<div id="for" class="section level3">
<h3><code>for</code></h3>
<p><code>for</code> allows us to iterate (or <em>loop</em>) over multiple elements. The general format for implementing a for loop in R is:</p>
<pre class="r"><code>for (i in vector) {
  
  # code here
  # usually doing something with vector[i]
  # where vector is an existing vector
  # and i is an arbitrary representation of a single element of that vector
  
}</code></pre>
<p>Let’s return to the example where we tried to use <code>if</code> / <code>else</code> with mulitple conditions:</p>
<pre class="r"><code>x &lt;- 1:10

if (x &gt; 5) {
  
  &quot;large&quot;
  
} else {
  
  &quot;small&quot;
  
}</code></pre>
<pre><code>## Warning in if (x &gt; 5) {: the condition has length &gt; 1 and only the first
## element will be used</code></pre>
<pre><code>## [1] &quot;small&quot;</code></pre>
<p>We saw how to get around this warning by using the vectorized <code>ifelse()</code>. But we can actually use <code>if</code> / <code>else</code> as well, we just need to do so inside of a for loop:</p>
<pre class="r"><code>for (i in x) {
  
  if (x[i] &gt; 5) {
    
    print(&quot;large&quot;)
    
  } else {
    
    print(&quot;small&quot;)
    
  }
  
}</code></pre>
<pre><code>## [1] &quot;small&quot;
## [1] &quot;small&quot;
## [1] &quot;small&quot;
## [1] &quot;small&quot;
## [1] &quot;small&quot;
## [1] &quot;large&quot;
## [1] &quot;large&quot;
## [1] &quot;large&quot;
## [1] &quot;large&quot;
## [1] &quot;large&quot;</code></pre>
<p>Note that in order to test each element in <code>x</code> we subset it at an index we are arbitrarily calling <code>i</code>, which represents each iteration. This is arbitrary in that we could have used another name (<code>var</code>, <code>num</code>, etc) for this index. But the vector <code>x</code> <em>does</em> need to exist in the environment.</p>
<p>It’s also worth pointing out that we’ve added an explicit <code>print()</code> around the return values. We need this for the output because automatic printing is turned off inside of loops<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
</div>
<div id="while" class="section level3">
<h3><code>while</code></h3>
<p><code>while</code> is another looping construct that you can use in R. The idea for while is to:</p>
<ol style="list-style-type: decimal">
<li>evaluate a logical condition</li>
<li>execute an action if that condition evaluates to <code>TRUE</code></li>
<li>continue executing that action until that condition is <code>FALSE</code></li>
</ol>
<pre class="r"><code>st &lt;- Sys.time()
et &lt;- Sys.time()

while (et &lt; st + 5) {
  print(&quot;busy&quot;)
}</code></pre>
<p>If we run the code above we see an <em>infinite loop</em> of <code>&quot;busy&quot;</code> … oops.</p>
<p>As described above, the <code>while</code> loop will continue executing as long as the condition remains <code>TRUE</code>. So in many cases you need to explicitly advance or modify what is being conditionally evaluated to avoid getting caught in a continuous loop.</p>
<pre class="r"><code>st &lt;- Sys.time()
et &lt;- Sys.time()

while (et &lt; st + 5) {
  print(&quot;busy&quot;)
  et &lt;- Sys.time()
}</code></pre>
</div>
<div id="repeat" class="section level3">
<h3><code>repeat</code></h3>
<p>If we want a loop to re-use the same expression over and over again, we can construct a <code>repeat</code> loop:</p>
<pre class="r"><code>repeat {
  
  x &lt;- sample(1:20,1)
  
  if(x == 2) {
    print(&quot;finally!&quot;)

  } else {
    
    print(x)
    
  }
  
}</code></pre>
<p>The code above will repeat the same expression … but as with our original <code>while</code> loop, it will do so infinitely. To make this kind a looping process effective, we need to be able to exit out of the loop</p>
</div>
<div id="break" class="section level3">
<h3><code>break</code></h3>
<p>There are several ways to navigate inside of a loop:</p>
<ul>
<li><code>break</code> = cancel execution and exit out of the loop silently</li>
<li><code>stop()</code> = cancel execution and error out of the loop</li>
<li><code>next</code> = proceed to the following iteration</li>
</ul>
<p>Going back to our <code>repeat</code> loop, we can actually resolve the infinite nature of the loop with <code>break</code>:</p>
<pre class="r"><code>repeat {
  
  x &lt;- sample(1:20,1)
  
  if(x == 2) {
    print(&quot;finally!&quot;)
    break

  } else {
    
    print(x)
    
  }
  
}</code></pre>
<pre><code>## [1] 9
## [1] 15
## [1] 4
## [1] 6
## [1] 8
## [1] 15
## [1] 20
## [1] &quot;finally!&quot;</code></pre>
<p>Let’s set up another example, which we’ll use to compare <code>break</code>, <code>stop()</code> and <code>next</code>:</p>
<pre class="r"><code>for (num in 2:20) {
  
  if (num %% 2 == 0) {
    
    print(num)
    
  } else {
    
    break
    
  }
  
}</code></pre>
<pre><code>## [1] 2</code></pre>
</div>
<div id="stop" class="section level3">
<h3><code>stop()</code></h3>
<p>We can use <code>stop()</code> to cancel execution as well:</p>
<pre class="r"><code>for (num in 2:20) {
  
  if (num %% 2 == 0) {
    
    print(num)
    
  } else {
    
    stop(&quot;not even&quot;)
    
  }
  
}</code></pre>
<pre><code>## [1] 2</code></pre>
<pre><code>## Error in eval(expr, envir, enclos): not even</code></pre>
<p>The important thing to point out with <code>stop()</code>, however, is that it behaves like a regular function (i.e. not a reserved word like <code>break</code>) and it returns an <em>error</em>.</p>
</div>
<div id="next" class="section level3">
<h3><code>next</code></h3>
<p>If we want advance through to the subsequent element rather than breaking or stopping execution altogether, we can use <code>next</code>:</p>
<pre class="r"><code>for (num in 2:20) {
  
  if (num %% 2 == 0) {
    
    print(num)
    
  } else {
    
    next
    
  }
  
}</code></pre>
<pre><code>## [1] 2
## [1] 4
## [1] 6
## [1] 8
## [1] 10
## [1] 12
## [1] 14
## [1] 16
## [1] 18
## [1] 20</code></pre>
</div>
<div id="apply-functions" class="section level3">
<h3>“apply” functions</h3>
<p>As an alternative to looping (and in particular <code>for</code> loops), R provides <em>functionals</em> for iterating across multiple elements. These are typically referred to as the “apply” family of functions, and they generally allow you to pass arbirtrary functions to each item in a vector or list.</p>
<p>There are a number varieties of apply functions, each which has its own use-case depending on the type of object over which it will be applied and the type of value it will return. We’ll look at three of the most commonly used:</p>
<ul>
<li><code>apply()</code> = useful for applying functions across rows or columns of matrices or data frames</li>
<li><code>lapply()</code> = passes an abritrary function across a list or vector and returns a list</li>
<li><code>sapply()</code> = a “simplified” version of <code>lapply()</code> … returns a vector</li>
</ul>
<p>For <code>apply()</code> we define the matrix or data frame we are working with (“X”), the dimension we want to apply across (“MARGIN”; 1 for rows, 2 for columns) and the function to use (“FUN”):</p>
<pre class="r"><code>apply(X = mtcars, MARGIN = 1, FUN = max)</code></pre>
<pre><code>##           Mazda RX4       Mazda RX4 Wag          Datsun 710 
##               160.0               160.0               108.0 
##      Hornet 4 Drive   Hornet Sportabout             Valiant 
##               258.0               360.0               225.0 
##          Duster 360           Merc 240D            Merc 230 
##               360.0               146.7               140.8 
##            Merc 280           Merc 280C          Merc 450SE 
##               167.6               167.6               275.8 
##          Merc 450SL         Merc 450SLC  Cadillac Fleetwood 
##               275.8               275.8               472.0 
## Lincoln Continental   Chrysler Imperial            Fiat 128 
##               460.0               440.0                78.7 
##         Honda Civic      Toyota Corolla       Toyota Corona 
##                75.7                71.1               120.1 
##    Dodge Challenger         AMC Javelin          Camaro Z28 
##               318.0               304.0               350.0 
##    Pontiac Firebird           Fiat X1-9       Porsche 914-2 
##               400.0                79.0               120.3 
##        Lotus Europa      Ford Pantera L        Ferrari Dino 
##               113.0               351.0               175.0 
##       Maserati Bora          Volvo 142E 
##               335.0               121.0</code></pre>
<pre class="r"><code>apply(X = mtcars, MARGIN = 2, FUN = mean)</code></pre>
<pre><code>##        mpg        cyl       disp         hp       drat         wt 
##  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250 
##       qsec         vs         am       gear       carb 
##  17.848750   0.437500   0.406250   3.687500   2.812500</code></pre>
<p><code>lapply()</code> (“list apply”) operates in a similar way but doesn’t need a specification for “MARGIN” since it works on lists and vectors:</p>
<pre class="r"><code>lapply(X = list(1:10, 5:20, 100:400), FUN = mean)</code></pre>
<pre><code>## [[1]]
## [1] 5.5
## 
## [[2]]
## [1] 12.5
## 
## [[3]]
## [1] 250</code></pre>
<p>Note that this returns a list.</p>
<pre class="r"><code>class(lapply(X = list(1:10, 5:20, 100:400), FUN = mean))</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<p><code>sapply()</code> with the same arguments “simplifies” the return value to a vector:</p>
<pre class="r"><code>sapply(X = list(1:10, 5:20, 100:400), FUN = mean)</code></pre>
<pre><code>## [1]   5.5  12.5 250.0</code></pre>
<p>As we’ve seen <code>sapply()</code> and <code>lapply()</code> each work on lists. They also each work on vectors:</p>
<pre class="r"><code>lapply(c(&quot;dog&quot;, &quot;cat&quot;, &quot;rat&quot;), grepl, &quot;dog&quot;)</code></pre>
<pre><code>## [[1]]
## [1] TRUE
## 
## [[2]]
## [1] FALSE
## 
## [[3]]
## [1] FALSE</code></pre>
<pre class="r"><code>sapply(c(&quot;dog&quot;, &quot;cat&quot;, &quot;rat&quot;), grepl, &quot;dog&quot;)</code></pre>
<pre><code>##   dog   cat   rat 
##  TRUE FALSE FALSE</code></pre>
<p>By default <code>sapply()</code> returns a named vector, whereas <code>lapply()</code> returns a list with no names.</p>
<p>But it’s worth noting that these are fundamentally doing the same thing, just with slightly different outputs by default. If we wanted to coerce <code>sapply()</code> to give us an identical result to <code>lapply()</code>, we could:</p>
<pre class="r"><code>lres &lt;- lapply(c(&quot;dog&quot;, &quot;cat&quot;, &quot;rat&quot;), grepl, &quot;dog&quot;)
lres</code></pre>
<pre><code>## [[1]]
## [1] TRUE
## 
## [[2]]
## [1] FALSE
## 
## [[3]]
## [1] FALSE</code></pre>
<pre class="r"><code>sres &lt;- sapply(c(&quot;dog&quot;, &quot;cat&quot;, &quot;rat&quot;), grepl, &quot;dog&quot;, simplify = FALSE, USE.NAMES = FALSE)
sres</code></pre>
<pre><code>## [[1]]
## [1] TRUE
## 
## [[2]]
## [1] FALSE
## 
## [[3]]
## [1] FALSE</code></pre>
<pre class="r"><code>identical(lres, sres)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Also keep in mind that with the apply family we can also use <em>anonymous</em> functions, which are those that we write “on-the-fly” and are only available within the environment of the function in which they are executed:</p>
<pre class="r"><code>sapply(X = 1:10, FUN = function(x) x%%2 == 0)</code></pre>
<pre><code>##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE</code></pre>
<p>These apply functions can in some cases enhance performance when iterating over large objects. But a much more efficient approach to programming with many iterations is vectorization.</p>
</div>
<div id="vectorization" class="section level3">
<h3>Vectorization</h3>
<p>As we’ve seen, looping can help us implement some advanced logic in our code. But can introduce challenges in terms of efficiency. Here we’ll briefly touch on alternative, <em>vectorized</em> approaches.</p>
<p>Let’s set up a simple loop:</p>
<pre class="r"><code>x &lt;- vector()
  
for (i in 1:1e7) {
  
  x[i] &lt;- i + i^2
    
}</code></pre>
<p>That seemed to take a while … let’s time it:</p>
<pre class="r"><code>system.time({
  
  x &lt;- vector()
  
  for (i in 1:1e7) {
    
    x[i] &lt;- i + i^2
    
  }
  
})</code></pre>
<pre><code>##    user  system elapsed 
##   3.461   0.931   4.416</code></pre>
<p>Let’s try the same thing with <code>sapply()</code>:</p>
<pre class="r"><code>y &lt;- sapply(1:1e7, function(x) x + x^2)</code></pre>
<p>That also took a while. How long?</p>
<pre class="r"><code>system.time({
  
  y &lt;- sapply(1:1e7, function(x) x + x^2)

})</code></pre>
<pre><code>##    user  system elapsed 
##  10.708   0.360  11.182</code></pre>
<p>OK … so the <code>for</code> loop and <code>apply</code> function were both about the same speed. What if we try a <em>vectorized</em> approach:</p>
<pre class="r"><code>z &lt;- 1:1e7 + (1:1e7)^2</code></pre>
<p>Much faster.</p>
<pre class="r"><code>system.time({
  
  z &lt;- 1:1e7 + (1:1e7)^2

})</code></pre>
<pre><code>##    user  system elapsed 
##   0.065   0.015   0.079</code></pre>
<pre class="r"><code>identical(x,y,z)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Vectorization can significantly increase the speed of code execution. The function being executed at each element of the vector <em>knows</em> the data type of the given element (because it is a homogenous vector), and can therefore skip any overhead involved with typing<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a><a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<p>Futhermore, the kinds of <code>for</code> loops we’ve written above force R to first create a vector … then retrieve it from memory … then add a new element … and repeat for the length of the vector over which we are iterating.</p>
<p>In some cases you can significantly speed up a loop by predefining a vector <em>with</em> the appropriate type (passed in the <em>mode</em> argument) and length:</p>
<pre class="r"><code>x &lt;- vector(mode = &quot;numeric&quot;, length=1e7)
  
for (i in 1:1e7) {
  
  x[i] &lt;- i + i^2
    
}</code></pre>
<pre class="r"><code>system.time({
  
  x &lt;- vector(mode = &quot;numeric&quot;, length=1e7)
    
  for (i in 1:1e7) {
    
    x[i] &lt;- i + i^2
      
  }
  
})</code></pre>
<pre><code>##    user  system elapsed 
##   0.584   0.013   0.597</code></pre>
</div>
<div id="further-resources" class="section level3">
<h3>Further Resources</h3>
<ul>
<li><a href="http://adv-r.had.co.nz/" class="uri">http://adv-r.had.co.nz/</a></li>
<li><a href="https://www.datamentor.io/r-programming/" class="uri">https://www.datamentor.io/r-programming/</a></li>
<li><a href="https://www.tutorialgateway.org/r-programming/" class="uri">https://www.tutorialgateway.org/r-programming/</a></li>
</ul>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://user2014.r-project.org/files/chambers.pdf" class="uri">http://user2014.r-project.org/files/chambers.pdf</a>]<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://stackoverflow.com/questions/7825501/switch-statement-usage" class="uri">https://stackoverflow.com/questions/7825501/switch-statement-usage</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://stackoverflow.com/questions/4716152/why-do-r-objects-not-print-in-a-function-or-a-for-loop?answertab=votes#tab-top" class="uri">https://stackoverflow.com/questions/4716152/why-do-r-objects-not-print-in-a-function-or-a-for-loop?answertab=votes#tab-top</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html" class="uri">http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="http://alyssafrazee.com/2014/01/29/vectorization.html" class="uri">http://alyssafrazee.com/2014/01/29/vectorization.html</a><a href="#fnref5">↩</a></p></li>
</ol>
</div>

    </article>
  </div>


<div class="site-footer">
  <div class="copyright">&copy; Copyright 2018 UVa School of Medicine Research Computing</div>
  <ul class="site-footer-items">
    <li class="site-footer-item-somrc"><a href="https://somrc.virginia.edu/" title="School of Medicine Research Computing">School of Medicine Research Computing</a></li>
  </ul>
</div>
<script src="/js/script.js"></script>
<script src="/js/custom.js"></script>


</body>
</html>
